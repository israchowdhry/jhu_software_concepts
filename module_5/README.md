SSH url: SSH url: git@github.com:israchowdhry/jhu_software_concepts.git

Name: Isra Chowdhry (ichowdh6)

Module Info: Module 5 Assignment: Software Assurance + Secure SQL (SQLi Defense) Due on 02/22/2026 at 11:59 EST

Approach:

This Module 5 submission extends the Grad Café Analytics project into a secure, production-ready web application that integrates database management, static analysis enforcement, full test coverage, dependency validation, and continuous integration security controls. The primary objective of this assignment was to apply secure software engineering principles by enforcing code quality, eliminating vulnerabilities, and implementing automated CI validation to ensure correctness before deployment.
The first step of the assignment focused on static code quality enforcement using Pylint. Pylint was installed in the development environment and executed against all Python files inside the src directory using the command pylint src --fail-under=10. All warnings, refactor suggestions, formatting issues, and structural concerns were resolved without disabling or silencing rules. This required refactoring certain logic blocks, improving docstrings, resolving line-length violations, restructuring shared state handling in the Flask app, and removing duplicate or unreachable code. The final result achieved a perfect 10.00/10 rating with no remaining warnings or errors at submission.
Database query safety and configuration hardening were implemented next. All SQL queries use parameterized statements via psycopg.sql to prevent SQL injection vulnerabilities. No dynamic string interpolation is used for query construction. Input limits are validated using a clamp_limit function that ensures all LIMIT values fall within safe bounds. Database connection logic was centralized into db_config.py, where the resolve_db_url function enforces secure configuration priority. The resolution order is: explicit db_url argument, DATABASE_URL environment variable, construction from DB_* environment variables, and finally raising a RuntimeError if no configuration is present. This ensures that credentials are never hardcoded and that both local and CI environments resolve connections safely.
Comprehensive test coverage was enforced using Pytest with pytest-cov. The project requires full coverage using the flags --cov=src --cov-report=term-missing --cov-fail-under=100. Every module in src was tested, including app.py, clean.py, db_config.py, load_data.py, query_data.py, and scrape.py. Additional edge-case tests were written specifically to cover fallback branches in database resolution, error paths in environment variable handling, JSONL ingestion behavior, Flask route execution, and end-to-end integration scenarios. The final result achieved 100% coverage across all source files.
The Flask web application was validated to ensure it runs correctly with PostgreSQL backing. The routes render properly, background pull operations function as expected, and analysis results display formatted output correctly. Thread-safe shared state management is handled using locking mechanisms. The application was tested locally using flask run and confirmed to operate correctly with a live database.
Security and environment hardening measures were applied by separating configuration into environment variables and ensuring no sensitive information is committed. Dependencies are pinned in requirements.txt to ensure reproducible builds. Artifacts generated for validation include coverage reports, dependency graphs, CI success screenshots, and Snyk analysis screenshots.
For supply-chain security, the Snyk CLI was installed and authenticated using a secure API token. The command snyk test was executed against the requirements.txt file to scan open-source dependencies for known vulnerabilities. The scan reported no vulnerable paths. A screenshot of the Snyk results was captured and included as snyk-analysis.png. This validates that the project dependencies are free of known security issues.
Continuous Integration enforcement was implemented using GitHub Actions via a workflow defined in .github/workflows/ci.yml. The pipeline runs on every push and pull request and performs the following checks: Pylint execution with fail-under=10, Pytest execution with enforced 100% coverage, generation of dependency.svg using pydeps and Graphviz (with job failure if missing), and Snyk dependency scanning using a repository secret token. A PostgreSQL service container is configured to support database-backed tests within the CI environment. This ensures that no code can be merged unless it satisfies static analysis, testing, dependency validation, and security requirements.
The overall architecture of the application follows a modular structure. The Flask interface resides in app.py, scraping logic in scrape.py, cleaning logic in clean.py, database ingestion in load_data.py, analytics queries in query_data.py, and secure configuration handling in db_config.py. All database interactions use parameterized queries, and connection logic is centralized to prevent duplication and reduce risk.
This project demonstrates secure software engineering principles through shift-left security practices. These include static analysis enforcement, 100% test coverage, secure configuration management, dependency supply-chain validation, SQL injection prevention, and automated CI policy enforcement. At final submission, the project achieves a Pylint score of 10.00/10, 100% Pytest coverage, a fully functioning Flask web application, a clean Snyk dependency scan, a generated dependency graph, and a fully passing GitHub Actions pipeline.
All Module 5 requirements have been successfully completed.


As required in Step 1, Pylint was installed in the project environment and executed against all Python files within the module_5/ directory. The command used was pylint src --fail-under=10, which analyzes the entire src/ package and automatically fails if the overall score drops below 10.00. All reported warnings and errors were resolved, including missing docstrings, line-length violations, duplicate code warnings, and structural issues. After making the necessary corrections, the final Pylint output displayed: “Your code has been rated at 10.00/10.” At final submission, there are no remaining Pylint warnings or errors, satisfying the requirement for a perfect static analysis score.

Fresh Install Instructions:

To set up the project from scratch using pip, first create a virtual environment using python -m venv .venv, then activate it (on Windows use .venv\Scripts\activate, and on Mac/Linux use source .venv/bin/activate). Once activated, upgrade pip and install all required dependencies using pip install --upgrade pip followed by pip install -r requirements.txt. After installing dependencies, install the project itself in editable mode using pip install -e .. Editable installation ensures imports behave consistently across local development, testing, and CI environments, preventing common path-related issues.

To install using uv, create a virtual environment with uv venv, then synchronize dependencies exactly as specified in requirements.txt using uv pip sync requirements.txt. This guarantees that the environment matches the requirements file precisely, improving reproducibility. After syncing, install the package in editable mode using uv pip install -e ..

The application requires database configuration via environment variables. You may either define DB_HOST, DB_PORT, DB_NAME, DB_USER, and DB_PASSWORD, or provide a full DATABASE_URL. These values can be placed in a .env file (which should not be committed to version control). An example configuration file is included to demonstrate required variable names.

To verify correctness, run pytest to execute the full test suite. The project enforces 100% coverage and includes tests for SQL injection safety, database behavior, Flask routes, and end-to-end flows. To verify code quality, run pylint src, which should complete without errors and achieve a full lint score.

To run the web application, execute python -m src.app and open http://localhost:8080 in your browser. The interface allows you to trigger the ETL pipeline, update analysis results, and view formatted analytics output.

This project includes a setup.py file so it can be installed as a proper Python package. Packaging ensures consistent import behavior across environments, supports editable installs, reduces “works on my machine” issues, improves CI reliability, and allows tools such as uv to synchronize dependencies accurately. If a fresh install works using either pip or uv, pytest passes with 100% coverage, pylint passes cleanly, and the Flask app runs successfully, then Step 5 requirements are fully satisfied.

Known bugs: No known bugs